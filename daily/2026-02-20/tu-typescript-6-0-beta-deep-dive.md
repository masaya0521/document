# TypeScript 6.0/7.0 深掘り — Go 書き直しと言語ランタイムの並行性モデル

- **日付**: 2026-02-20
- **カテゴリ**: Language / Runtime
- **関連**: [TypeScript 6.0 Beta 概要](./tu-typescript-6-0-beta.md)

## 1. TypeScript 7.0 を Go で書き直す背景

### なぜ書き直すのか

2025 年 3 月、Anders Hejlsberg（TypeScript の生みの親）が TypeScript コンパイラを Go で書き直すことを発表した。プロジェクト名は通称「tsgo」「TypeScript native」。

根本的な問題は**パフォーマンス**にある。TypeScript コンパイラ自体が TypeScript（JavaScript）で書かれているため、以下の限界がある：

- **大規模プロジェクトで型チェックが遅い** — 数万ファイルのプロジェクトだとビルドに数十秒〜数分
- **エディタの IntelliSense が重くなる** — 型推論の計算量が多いと補完やエラー表示が遅延
- **JavaScript のシングルスレッド制約** — 並列処理が根本的に難しい（後述）

### なぜ Go を選んだのか

Rust や C++ ではなく Go を選んだ理由：

1. **構造的な類似性** — TypeScript コンパイラの内部構造（データ構造、制御フロー）が Go に自然に移植しやすい
2. **GC がある** — コンパイラは大量のオブジェクトを生成・破棄するため、手動メモリ管理（Rust/C++）は開発コストが高い
3. **goroutine による並列型チェック** — ファイルごとに goroutine を起動して並列に型チェック可能（後述）
4. **チームの生産性** — Go のシンプルさが大規模チームでの開発効率に寄与

Rust を選ばなかった理由は、所有権モデルがコンパイラの**木構造（AST）操作**と相性が悪く、開発速度が大幅に落ちるという判断。

### 10 倍高速化の根拠

公式には**ビルド速度が最大 10 倍向上**とされている：

- **ネイティブコンパイル（AOT）** — V8 の JIT ではなく、事前にマシンコードにコンパイル
- **マルチスレッド並列処理** — goroutine による並列型チェック
- **メモリレイアウト最適化** — Go のメモリ管理は V8 より効率的

## 2. JavaScript のシングルスレッドモデル

TypeScript コンパイラが JavaScript で書かれていることの限界を理解するには、JavaScript の実行モデルを知る必要がある。

### Event Loop の仕組み

JavaScript は**シングルスレッド**で、**Event Loop** で動作する。

**I/O バウンド処理**（ファイル読み込み、DB 問合せなど）は並行可能：

```
時間軸 →
メインスレッド:
  [req1: DB問合せ開始] → [req2: DB問合せ開始] → [req3: DB問合せ開始]
                                                → [req1: DB結果返却]
                                                → [req2: DB結果返却]
```

OS が裏でディスクやネットワークの I/O を処理している間、メインスレッドは次のリクエストを処理できる。

**CPU バウンド処理**（型チェックなど計算が重い処理）は直列：

```
JavaScript（シングルスレッド）:
  ファイルAの型チェック → ファイルBの型チェック → ファイルCの型チェック
  |----- 1秒 -----|----- 1秒 -----|----- 1秒 -----|
  合計: 3秒
```

CPU を使い続ける計算の間、他の処理は全てブロックされる。これが TypeScript コンパイラのボトルネック。

### ECS での Node.js スケーリング

Node.js（JavaScript）の Web サーバーは、1 コンテナ 1 スレッドで動作する。ただし I/O 中心の Web API なら、1 コンテナでも数千の同時接続を処理可能。

```
ECS サービス:
┌──────────┐  ┌──────────┐  ┌──────────┐
│ タスク1    │  │ タスク2    │  │ タスク3    │
│ 1スレッド  │  │ 1スレッド  │  │ 1スレッド  │
└──────────┘  └──────────┘  └──────────┘
      ↑              ↑              ↑
      └──── ALB がリクエストを振り分ける ────┘
```

コンテナ数を増やすのは主に以下のケース：

- CPU 使用率が上がったとき
- 可用性の確保（1 コンテナが落ちても他で処理を続ける）
- レイテンシの確保（Event Loop の 1 周が遅くなったとき）

I/O がボトルネックの場合、Go でも JavaScript でも性能差はほとんどない。I/O 待ちの時間は OS やハードウェアが決めるものだから。

## 3. Go の goroutine と M:N スケジューリング

### goroutine とは

goroutine は OS スレッドではなく、Go ランタイムが管理する**軽量な実行単位**。

Go は **M:N スケジューリング** を採用している。M 個の goroutine を N 個の OS スレッドに割り当てる：

```
┌──────────────────────────────────────────┐
│              Go プロセス                   │
│                                          │
│  goroutine:  g1  g2  g3  g4  g5  g6     │  ← 数千〜数万個作れる
│               ↓   ↓   ↓   ↓   ↓   ↓     │
│  Go スケジューラが割り当てる                  │
│               ↓   ↓       ↓   ↓         │
│  OS スレッド: [T1]      [T2]      [T3]    │  ← CPU コア数程度
│               ↓          ↓        ↓      │
│  CPU コア:  [Core1]   [Core2]  [Core3]    │
└──────────────────────────────────────────┘
```

goroutine が I/O 待ちやチャネル待ちで止まると、スケジューラはそのスレッドに**別の goroutine を乗せて**動かし続ける。

### OS スレッドとの比較

|  | OS スレッド | goroutine |
|--|-----------|-----------|
| メモリ | 1〜8 MB（スタック） | 数 KB（初期 2KB、自動拡張） |
| 起動コスト | マイクロ秒〜ミリ秒 | ナノ秒〜マイクロ秒 |
| 切り替えコスト | カーネル介入が必要 | ユーザー空間で完結 |
| 同時数 | 数百〜数千が限界 | 数十万でも問題ない |

### Go の Web サーバーと Node.js の違い

Go は 1 プロセスで複数の CPU コアを使い切れるため、少ないコンテナ数で同等の処理が可能：

```
Go（1コンテナ）:
┌─────────────────────────────────┐
│          1つのプロセス             │
│  goroutine × 数千〜数万           │
│  （複数コアで並列処理）             │
└─────────────────────────────────┘

Node.js（同等の処理には複数コンテナが必要な場合がある）:
┌──────────┐  ┌──────────┐  ┌──────────┐
│ 1スレッド  │  │ 1スレッド  │  │ 1スレッド  │
└──────────┘  └──────────┘  └──────────┘
```

ただし I/O 中心の Web API では実質的な差は小さい。大きな差が出るのは CPU を使う処理が混ざる場合（JSON シリアライズ、テンプレートレンダリング、データ集計など）。

### TypeScript コンパイラの文脈

コンパイラの型チェックは**ほぼ 100% CPU 計算**で、I/O は最初のファイル読み込みだけ。Go で書き直せば：

```
Go（goroutine で並列）:
  ファイルAの型チェック ─────|
  ファイルBの型チェック ─────|
  ファイルCの型チェック ─────|
  合計: 約1秒（3コアで並列処理）
```

AST（構文木）や型情報という巨大なデータ構造を複数の処理が参照する必要があるため、**同じメモリ空間を共有できる** goroutine が適している。

## 4. 各言語の並行性モデル比較

Web サーバーの観点から、主要言語の並行性モデルを比較する。

### Rust — async/await + スレッド

- **並行モデル**: OS スレッド + async/await（tokio ランタイム）
- Go と同等かそれ以上の性能。GC がないのでレイテンシのスパイクがない
- 所有権システムにより**コンパイル時にデータ競合を防げる**
- 開発速度は Go や Node.js の 1.5〜2 倍かかると言われる
- **向いている場面**: 極限の性能が必要なインフラ（Cloudflare のエッジプロキシ、Discord のメッセージ基盤など）

### Python — GIL による実質シングルスレッド

- **並行モデル**: GIL（Global Interpreter Lock）がある
- マルチスレッドで書いても、CPU 計算は実質シングルスレッド
- Node.js と同じシングルスレッドの制約に加えて、インタープリタの実行速度自体が遅い
- **FastAPI + uvicorn** で async を使えば I/O バウンドな API はそこそこ速い
- **選ばれる理由**: AI/ML エコシステム（PyTorch、NumPy 等）が圧倒的
- **補足**: Python 3.13 で GIL を無効化する実験的機能（`--disable-gil`）が登場

### PHP — shared-nothing アーキテクチャ

- **並行モデル**: リクエストごとにプロセスが起動する
- 各リクエストが独立したプロセスで処理され、リクエスト終了時にメモリが全て解放される
- **メリット**: メモリリークが原理的に起きにくい。1 リクエストがクラッシュしても他に影響しない
- **デメリット**: プロセス間でデータを共有できず、WebSocket のような長時間接続は苦手
- PHP 8 系で JIT が入り性能が大幅に改善
- **選ばれる理由**: WordPress（Web の約 40%）、Laravel の生産性

### Ruby — GVL + Puma マルチプロセス

- **並行モデル**: GVL（Global VM Lock）があり、Python と似た制約
- Puma（Web サーバー）がマルチプロセス + マルチスレッドで対応
- CPU 計算はプロセス単位でしか並列化できない
- **選ばれる理由**: 「Convention over Configuration」の思想で少人数で素早くプロダクトを作れる。GitHub、Shopify、Basecamp など実績多数
- **補足**: Ruby 3 で Ractor（Actor ベースの並行性）が導入されたが、まだ実用段階には至っていない

### 性能・特性比較表

| 言語 | CPU 性能 | 並行モデル | 開発速度 | 主な採用理由 |
|------|---------|-----------|---------|------------|
| Rust | 最速 | async + スレッド | 遅い | 極限性能が必要な場面 |
| Go | 非常に速い | goroutine（M:N） | 速い | インフラ、CLI、マイクロサービス |
| Node.js | 中程度 | Event Loop（シングルスレッド） | 速い | フロント統一、エコシステム |
| PHP | 中程度 | プロセスベース | 速い | WordPress、Laravel |
| Ruby | 遅め | GVL + マルチプロセス | 非常に速い | 少人数での高速プロダクト開発 |
| Python | 遅い | GIL（実質シングルスレッド） | 速い | AI/ML、データサイエンス |

純粋な性能だけなら **Rust > Go > Node.js > PHP > Ruby ≒ Python** だが、実際のプロジェクトでは開発速度、チームのスキルセット、エコシステムの方が重要な判断基準になることが多い。

## 5. 補足: GC（ガベージコレクション）の基礎

TypeScript 7.0 が Go を選んだ理由の一つに「GC がある」ことが挙げられた。GC の基本を補足する。

### メモリ管理の 3 つのアプローチ

1. **手動管理**（C / C++）— `malloc` で確保、`free` で解放。忘れるとメモリリーク、早すぎると use-after-free
2. **所有権システム**（Rust）— コンパイル時に所有権を追跡し、スコープを抜けたら自動解放。実行時コストゼロ
3. **GC**（Go, Java, Python, JavaScript 等）— ランタイムが「もう使われていないメモリ」を自動検出して回収

### マーク&スイープの仕組み

Go の GC は**マーク&スイープ**方式：

1. **ルートの特定** — スタック上の変数、グローバル変数、レジスタのポインタを見つける
2. **マーク** — ルートからポインタを辿り、到達可能なオブジェクトを「生きている」と印付け。**ワークリスト**で未訪問のオブジェクトを管理し、到達可能な全オブジェクトを探索
3. **スイープ** — マークされなかったオブジェクトのメモリを解放し、再利用可能にする

Go の GC は**アプリケーションと並行して動作（Concurrent GC）** する。STW（Stop-The-World）はマイクロ秒単位に抑えられており、**書き込みバリア**でアプリが参照を変更したことを GC に通知する仕組みで整合性を保つ。

コンパイラのような大量のオブジェクトを生成・破棄するワークロードでは、GC があることで開発者はメモリ管理を意識せずに済み、開発効率が大きく向上する。これが Rust ではなく Go が選ばれた理由の一つ。
